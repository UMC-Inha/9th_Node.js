* 데이터베이스 정규화

  ### 데이터의 중복성을 허락하지 않음으로서 데이터의 무결성을 유지하도록 하는 프로세스

  데이터 정규화는 총 단계에 따라 5단계 까지 수행할 수 있다.


  ```
    1. 제 1 정규형 (1NF): 모든 열이 원자값을 가지며, 중복된 그룹이 없어야 한다.
    2. 제 2 정규형 (2NF): 1NF를 충족하며, 부분 함수 종속이 없어야 한다.
    3. 제 3 정규형 (3NF): 2NF를 충족하며, 이행적 종속이 없어야 한다.
    4. 제 4 정규형 (BCNF): 모든 결정자가 후보 키여야 하며, 다치 종속이 없어야 한다.
    5. 제 5 정규형 (5NF): 모든 조인 종속이 후보 키에 의존해야 하며, 조인에 의해 불필요한 데이터 중복이 없어야 한다.
  ```
  * **장점** : 중복 감소, 무결성 강화, 유지보수 용이
  * **단점** : JOIN 증가, 성능 저하, 과한 정규화로 많아지는 테이블 수
* 인덱스(Index)

  ## 추가적인 쓰기 작업과 저장공간을 활용해 데이터베이스 테이블의 검색속도를 향상 시키기 위한 자료구조

  [index가 뭔지 설명해보세요 (개발면접시간)](https://youtu.be/iNvYsGKelYs?si=7imtXdCBpxt8nyY3)

  ![image.png](attachment:34eff3b7-07c6-4ff8-8ffb-18e8c6b8a5db:image.png)

  ![image.png](attachment:78fcca5b-ace6-464a-8ccf-cb0491613641:image.png)

  ![image.png](attachment:f75220f1-a9ed-4f3e-95c9-12fea9588d4a:image.png)

  DBMS는 index를 **항상 정렬된** 상태로 유지해야 원하는 값을 빠르게 탐색 할 수 있다. 따라서 추가연산 오버헤드가 발생한다.


  * INSERT: 새로운 데이터에 대한 인덱스를 추가함
  * DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함
  * UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가함

  따라서 자료 입출력이 번번한 속성에 index를 걸게 되면 index의 크기가 비대해지기 때문에 성능이 저하되는 역효과가 발생 할 수 있다.
  **자료구조 유형**

  > 자료구조 시간에 배운 그거 맞습니다
  >

  ### Hash Table

  key-value 값으로 지정된 자료구조, 빠른 데이터 검색이 필요할때 유용하다
  ![image.png](attachment:57070bcd-13fb-4320-a931-4c4abb22523a:image.png)
  해시함수를 통해 고유한 인덱스를 생성하고 할당하여 관리하게 된다.
  다만 해시값이 중복될 수도 있으므로 충돌된 해시값을 정리하는 별도의 과정이 필요하다.

  * 데이터 조회
    평균: `O(1)` - 각각의 Key값은 해시함수에 의해 고유한 index를 가지므로 데이터에 바로 접근
    최악: `O(N)` - 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야 하므로
  * 충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만 **공간을 많이 사용한다는 치명적인 단점**이 있다. 만약 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확정을 하지 않도록 테이블을 설계해주어야 한다.
    (통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)

  ### B+Tree

  ![image.png](attachment:7fb79903-2fae-4b54-b090-bb78130bf757:image.png)
  B Tree 를 개선시켜 순차검색 연산을 용이하게 만드는 자료구조,
  리프노드끼리는 Linked List로 연결되어 있어 순회검색(예를 들어 위 사진에서 2~6까지 검색) 에 용이하다.

  ### Bitmap

  ![image.png](attachment:8cf2564f-971b-4451-ac02-d1b5f1ff8fd3:image.png)
  인덱스 컬럼의 데이터를 0 or 1로 변환하여 인덱스 키로 사용하는 방법, B+Tree와 달리 카디널리티 값이 낮은 경우 사용하기 좋다.

  ### Clustered Index

  테이블 전체가 해당 인덱스를 기준으로 정렬되는 방식(PK), 테이블당 1개만 존재 할 수 있다.
  MySQL(InnoDB)에서는 PK 없으면 내부적으로 **Unique NOT NULL 컬럼**을 Clustered Index로 잡거나, 없으면 **숨겨진 RowID**를 Clustered Index로 만들어줌
* ORM VS Raw SQL

  ### ORM(Object Relation Mapping)

  ![image.png](attachment:74d78f3a-ea18-48b2-8311-af4e46b01547:image.png)

  객체지향 언어의 객체(Class) ↔ 관계형 DB의 테이블(Row/Column)을 자동으로 매핑해주는 기술, 개발자는 SQL을 직접 작성하지 않고 **객체 지향적 코드**로 DB 작업을 수행 할 수 있음.

  예: Java(Spring) → Hibernate/JPA, Python → SQLAlchemy, Node.js → Sequelize/Prisma 등


  * 장점
    * 직관적인 코드로 생산성증가
    * DB 독립성 증가(동일한 코드로 MYSQL, PostgreSQL, MongoDB등 사용 가능)
    * 유지보수성 증가
    * 높은 보안
    * 스키마가 변경되었을때 자동으로 반영 가능
  * 단점
    * 성능저하
    * 복잡한처리 불가
    * 추가적인 학습 필요

  ### Raw SQL

  개발자가 직접 SQL 구문을 작성하여 DB와 상호작용하는 방식, ORM 레이어를 거치지 않고 순수하게 SQL로 DB와 직접 소통함

  * 장점
    * 최적화 가능
    * 복잡한 쿼리 지원
    * 직관적인 디버깅
  * 단점
    * 생산성 저하
    * DB 종속성
    * 보안 이슈
