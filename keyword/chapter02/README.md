# 1. 데이터베이스 정규화
| 정규형 | 정의 | 특징/조건 | 예시 |
| --- | --- | --- | --- |
| **1NF (First Normal Form)** | 원자값만 허용 | 컬럼 값이 **더 이상 쪼갤 수 없는 값**이어야 함 | 전화번호를 `123-4567, 234-5678` → 여러 행으로 분리 |
| **2NF (Second Normal Form)** | 1NF + **부분 함수 종속 제거** | 복합키가 있을 때, **키의 일부에만 종속된 컬럼 제거** | 주문 테이블에서 `(주문ID, 상품ID)` 복합키인데, 고객 이름이 주문ID만 종속 → 고객 테이블로 분리 |
| **3NF (Third Normal Form)** | 2NF + **이행적 종속 제거** | **키가 아닌 컬럼이 다른 컬럼에 의존하면 안됨** | `도시 → 우편번호`, `회원 → 도시` → 우편번호 컬럼 분리 |


# 2. 인덱스
- 인덱스
    - 색인 개념으로, 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어 두는 것, ex) name 칼럼에 인덱스 만들면 “철수” 라는 키로 해당 레코드의 저장 위치를 바로 찾기 가능
    - 인덱스에서 중요한 것은 ‘정렬’이다. 인덱스는 SortedList 자료구조 형식이다.
    - 인덱스가 많은 테이블은 insert, update, delete 처리가 느려진다. 그래도 select는 엄청 빠르다.
    - 결국, index는 데이터 저장 성능은 희생하고, 읽기 속도를 높이는 기능
- 인덱스를 역할로 구분해본다면?
    - 프라이머리 키: 해당 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스, 식별자라고 부르며 not null
    - 보조 키: 프라이머리 키를 제외한 모든 인덱스
- 데이터 저장 방식(알고리즘)별로 구분해본다면?
    - B-Tree 인덱스: 가장 일반적, 칼럼의 값을 변형하지 않고, 원래 값을 이용해 인덱싱.
    - Hash 인덱스: 칼럼의 값으로 해시값을 계산해 인덱싱, 매우 빠른 검색 지원. but 값을 변형해서 인덱싱 하기 때문에 전방 일치와 같이 일부 검색하거나 범위 검색 시 사용 불가(주로 메모리 기반 DB에서 사용)
    - Fractal-Tree 인덱스
    - 로그 기반 Merge-Tree 인덱스
- 데이터 중복 허용 여부로 구분해본다면?
    - 일반 인덱스 (INDEX): 검색 속도를 빠르게 해줄 뿐, 값이 중복되어도 됨.
    - 유니크 인덱스 (UNIQUE INDEX): 검색 속도 + 중복 방지 기능을 동시에 제공.

## Reference

- RealSQL p214~281

# 3. ORM vs Raw SQL
- orm이란 (Object-Relational Mapping)
    - 프로그래밍 언어 상 객체와, 데이터베이스 요소 간 연결을 추상화하는 프로세스
    - 관리 및 유지보수가 쉬운 어플리케이션을 만들 수 있음
- ORM vs ORDBMS
    - ORDBMS는 관계형 프레임워크와 객체 지향 프레임워크 요소를 모두 사용하는 DB 유형
    - 객체 지향 언어로 코딩하는 것고 유사하게 객체 구조의 레코드를 저장할 수 있음
- ORM의 이점
    - 적은 코드 양 > 유지 관리 쉬워짐
    - 디버깅 난이도 쉬워짐
    - 보안 강화
        - SQL 인젝션 공격: 공격자가 웹의 입력 폼에 악의적인 SQL 코드 삽입해서 DB에 접근하거나 데이터를 조작하는 공격
        - ORM은 매개변수화된 쿼리를 사용하여 자리 표시자(? 또는 :param)를 쿼리에 넣고, 실제 값은 별도로 전달
        - 자리 표시자 안에 들어간 구문은 SQL 구문으로 실행되지 않고 값으로 취급되기 때문에 안전!
            
            ```sql
            select * from user where username = '사용자입력' and password = '사용자입력';
            
            # 공격 받은 후 쿼리
            # username에 ' or '1'=' 을 삽입
            select * from user where username = '' or '1'='1' and password = '';
            ```
            
    - 성능 향상: 애플리케이션 계층에서 객체 캐싱을 통해 시스템 성능 향상시킬 수 있음
        - 자주 검색되는 데이터를 애플리케이션에 더 가까운 곳에 저장하여 더 빠른 엑세스 제공
- ORM의 단점
    - 임피던스 불일치: 복잡한 데이터 구조는 ORM만으로 매핑하기 어려울 수 있음
    - 더 높은 복잡성에서의 성능 문제: 아무래도 직접 쿼리하는 것이 ORM보다 계산 효율이 더 높음. 매우 복잡한 쿼리일 경우 SQL이 더 효율적
    - 학습 곡선: 언어마다 ORM 도구 사용법을 배워야 하기 때문
- 언제 ORM을 사용할까
    - 유사한 쿼리를 반복한다면!
    - 많은 객체가 있는 경우 > 많은 쿼리를 수동으로 작성하는 것은 엄청난 시간과 노력 투자
- 언제 ORM을 지양해야하나
    - 간단한 DB 상호작용의 경우
    - 고성능 컴퓨팅이 중요한 경우, 많은 애플리케이션에서는 사실 ORM으로 인해 추가되는 시간 및 리소스는 중요 X, but 밀리초 단위 처리가 중요한 실시간 분석과 같은 작업에서는 ORM은 부적합
    - 비정규화된 스키마 사용할 때

## Reference

https://aws.amazon.com/what-is/object-relational-mapping/